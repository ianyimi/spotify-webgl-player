/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.2 public/staging/vintageTelevision/vintageTelevision.glb C:/Program Files/Git/src/models/vintageTelevision.tsx -d -t -v -p 4
*/

import { Group, Mesh, MeshStandardMaterial, MeshPhysicalMaterial, Scene, PerspectiveCamera, Vector3 } from 'three';
import { Dispatch, ReactElement, SetStateAction, useCallback, useEffect, useRef, useState } from 'react';
import { useCursor, useFBO, useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { Quaternion, Object3D } from "three";

import { gsap } from "gsap";
import { useSceneMaterial } from "../../public/shaders/scene/index";
import { useRouter } from "next/router";
import { useFrame, useThree, createPortal, ThreeEvent } from "@react-three/fiber";
import { useClientStore } from "@/hooks/useStore";
import { CameraRig } from "three-story-controls";
import { AnimationDuration, AnimationEase } from 'types/common';

type GLTFResult = GLTF & {
  nodes: {
    TV: Mesh
    TVSCREEN: Mesh
    TVSCREENBEZEL: Mesh
  }
  materials: {
    ['TV_Chayka-206']: MeshStandardMaterial
  }
}

type VintageTelevisionProps = {
  intensity?: number,
	playlistID?: string,
  route?: string,
  url?: string,
  index?: number,
  children?: ReactElement[],
	focusedPlaylist?: string,
	setFocusPlaylistID?: Dispatch<SetStateAction<string>>
} & JSX.IntrinsicElements['group']

const glassMat = new MeshPhysicalMaterial( { roughness: 0, transmission: 1 } );
const FILE_URL = "https://dqeczc7c9n9n1.cloudfront.net/models/vintageTelevision-1672798597/vintageTelevision.glb.gz";
const URL_NOT_FOUND = "https://dqeczc7c9n9n1.cloudfront.net/images/404.png";

export default function Model( props: VintageTelevisionProps ) {

	const router = useRouter();
	const group = useRef<Group>( null );
	const [ hovered, hover ] = useState( false );
	const dummyCamera = useRef( new Object3D() );
	const worldPosition = useRef( new Vector3() );
	const worldQuaternion = useRef( new Quaternion() );
	const { url = URL_NOT_FOUND, playlistID, focusedPlaylist, setFocusPlaylistID, index = 0, intensity = 200, children, ...restProps } = props;
	const { nodes, materials } = useGLTF( FILE_URL ) as unknown as GLTFResult;

	useCursor( hovered );

	const screen = useRef( null );
	const fbo = useRef( useFBO() );
	const { events, gl, scene: originScene, camera: originCamera } = useThree();
	const cameraInit = useRef( false );
	const [ activeScene, present, setFuture, setActiveScene, paneSettings, sceneImmersion, sceneReversion ] = useClientStore( state => [ state.activeScene, state.present, state.setFuture, state.setActiveScene, state.paneSettings, state.sceneImmersion, state.sceneReversion ] );
	// The portal will render into this scene
	const [ futureScene ] = useState( () => new Scene() );
	// We have our own camera in here, separate from the default
	const [ futureCamera ] = useState( () => new PerspectiveCamera( 50, 1, 0.1, 1000 ) );
	const cameraRig = useRef( new CameraRig( futureCamera, futureScene ) );
	const tvMat = useSceneMaterial( {
		url: url,
		intensity: intensity,
		renderedScene: children ? fbo.current.texture : undefined
	} );

	if ( focusedPlaylist !== playlistID ) {

		tvMat.uniforms.altScene.value = 0;

	}

	useEffect( () => {

		futureCamera.aspect = 0.5 / 0.42;
		futureCamera.updateProjectionMatrix();

		if ( group.current ) {

			group.current.getWorldPosition( worldPosition.current );
			group.current.getWorldQuaternion( worldQuaternion.current );

			worldPosition.current.y += 1.25;
			worldPosition.current.z += 4;
			worldQuaternion.current.normalize().invert();

		}

	}, [] );

	useFrame( ( state ) => {

		// Copy the default cameras whereabouts
		if ( ! cameraInit.current ) {

			futureCamera.position.copy( state.camera.position );
			futureCamera.rotation.copy( state.camera.rotation );
			futureCamera.scale.copy( state.camera.scale );
			dummyCamera.current.position.copy( state.camera.position );
			dummyCamera.current.rotation.copy( state.camera.rotation );
			dummyCamera.current.scale.copy( state.camera.scale );
			dummyCamera.current.lookAt( new Vector3() );
			cameraInit.current = true;

		}

		state.gl.setRenderTarget( fbo.current );
		state.gl.render( futureScene, futureCamera );
		state.gl.setRenderTarget( null );

		tvMat.uniforms.time.value = state.clock.getElapsedTime() / 2;
		tvMat.uniforms.intensity.value = intensity + ( intensity / 4 * Math.sin( state.clock.getElapsedTime() ) );

	} );

	// This is a custom raycast-compute function, it controls how the raycaster functions.
	const compute = useCallback( ( event, state, previous ) => {

		// First we call the previous state-onion-layers compute, this is what makes it possible to nest portals
		if ( ! previous.raycaster.camera ) previous.events.compute( event, previous, previous.previousRoot?.getState() );
		// We run a quick check against the textured plane itself, if it isn't hit there's no need to raycast at all
		const [ intersection ] = previous.raycaster.intersectObject( screen.current );
		if ( ! intersection ) return false;
		// We take that hits uv coords, set up this layers raycaster, et voil√†, we have raycasting with perspective shift
		const uv = intersection.uv;
		state.raycaster.setFromCamera( state.pointer.set( uv.x * 2 - 1, uv.y * 2 - 1 ), futureCamera );

	}, [] );

	const handleClick = ( e: ThreeEvent<MouseEvent> ) => {

		e.intersections.length = 1;

		if ( ! present || ! group.current || activeScene === 2 ) return;
		if ( ! worldPosition.current || ! worldQuaternion.current ) return;
		if ( focusedPlaylist === playlistID ) {

			present.rig.flyTo( group.current.position, worldQuaternion.current, AnimationDuration.CameraMotion, AnimationEase.CubicBezier );
			sceneImmersion();
			setTimeout( () => {

				sceneReversion();

			}, 3000 );

		}

		tvMat.uniforms.altScene.value = 1;
		setFocusPlaylistID && setFocusPlaylistID( playlistID ?? "" );
		// tvMat.uniforms.altScene.value = 1;
		setFuture( fbo.current, futureScene, futureCamera, cameraRig.current );
		present.rig.flyTo( worldPosition.current, worldQuaternion.current, AnimationDuration.CameraMotion, AnimationEase.CubicBezier );


	};

	return (
		<group ref={group} {...restProps} dispose={null}>
			{/* <mesh position={[ 0, 1.25, 2 ]}>
				<boxBufferGeometry args={[ 1.25, 1.25, 1.25 ]} />
				<meshBasicMaterial color="red" />
			</mesh> */}
			<group
				name="Scene"
				onClick={( e ) => handleClick( e )}
				onPointerOver={() => hover( true )}
				onPointerOut={() => hover( false )}
			>
				<mesh
					geometry={nodes.TV.geometry}
					material={materials[ 'TV_Chayka-206' ]}
					position={[ - 0.0011, 0.0054, - 0.0071 ]}
					scale={5.0041}
				/>
				<mesh
					geometry={nodes.TVSCREEN.geometry}
					args={[ nodes.TVSCREEN.geometry, glassMat ]}
					position={[ - 0.0011, 0.0054, - 0.0071 ]}
					scale={5.0809}
				>
					<mesh ref={screen} material={tvMat} position={[ - 0.085, 0.2525, 0.15 ]}>
						<planeGeometry args={[ 0.5, 0.42 ]}/>
					</mesh>
					{children && createPortal( children, futureScene, {
						gl,
						camera: futureCamera,
						scene: futureScene,
						events: { compute, priority: events.priority - 1 }
					} )}
				</mesh>
				<mesh
					geometry={nodes.TVSCREENBEZEL.geometry}
					material={materials[ 'TV_Chayka-206' ]}
					position={[ - 0.4388, 1.2966, 0.8396 ]}
					scale={[ 5.1008, 5.1032, 4.9647 ]}
				/>
			</group>
		</group>
	);

}

useGLTF.preload( FILE_URL );
