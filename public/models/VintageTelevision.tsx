/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import { gsap } from "gsap";
import React, { ReactElement, useCallback, useEffect, useRef, useState } from 'react';
import { useCursor, useFBO, useGLTF } from '@react-three/drei';
import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader';
import { useVintageScreenMaterial } from "../shaders/vintageScreen";
import { useSceneMaterial } from "../shaders/scene";
import { useRouter } from "next/router";
import { useFrame, useThree, createPortal } from "@react-three/fiber";
import usePostProcess from "@/templates/hooks/usePostprocess";
import { useClientStore } from "@/templates/hooks/useStore";

import { Index } from "lib/CameraRig";

import dynamic from "next/dynamic";

// const CameraRig = dynamic( () => import( "/lib/CameraRig/CameraRig.js" ).then( c => c.CameraRig ), { ssr: false } );
// const CameraAction = dynamic( () => import( "three-story-controls" ).then( c => c.CameraAction ), { ssr: false } );

type GLTFResult = GLTF & {
  nodes: {
    TV: THREE.Mesh
    TVSCREEN: THREE.Mesh
    TVSCREENBEZEL: THREE.Mesh
  }
  materials: {
    ['TV_Chayka-206']: THREE.MeshStandardMaterial
  }
}

type VintageTelevisionProps = {
  intensity?: number,
  route?: string,
  url?: string,
  index?: number,
  children?: ReactElement[]
} & JSX.IntrinsicElements['group']

const glassMat = new THREE.MeshPhysicalMaterial( { roughness: 0, transmission: 1 } );
const FILE_URL = "https://dqeczc7c9n9n1.cloudfront.net/models/vintageTelevision-1669157713/vintageTelevision.glb.gz";
const URL_NOT_FOUND = "https://dqeczc7c9n9n1.cloudfront.net/images/404.png";

export default function Model( props: VintageTelevisionProps ) {

	const router = useRouter();
	const [ hovered, hover ] = useState( false );
	const { url = URL_NOT_FOUND, route, index = 0, intensity = 200, children, ...restProps } = props;
	const group = useRef<THREE.Group>( null );
	const { nodes, materials } = useGLTF( FILE_URL ) as GLTFResult;
	const tvMat = useVintageScreenMaterial( { url: url, intensity: intensity } );


	useCursor( hovered );

	const ref = useRef( null );
	const fbo = useRef( useFBO() );
	const dummyFBO = useFBO();
	const { events, gl, scene: originScene, camera: originCamera } = useThree();
	const cameraInit = useRef( false );
	const [ activeScene, present, future, setFuture, setActiveScene, paneSettings ] = useClientStore( state => [ state.activeScene, state.present, state.future, state.setFuture, state.setActiveScene, state.paneSettings ] );
	// The portal will render into this scene
	const [ scene ] = useState( () => new THREE.Scene() );
	// We have our own camera in here, separate from the default
	const [ camera ] = useState( () => new THREE.PerspectiveCamera( 50, 1, 0.1, 1000 ) );
	// eslint-disable-next-line @typescript-eslint/ban-ts-comment
	// @ts-ignore
	const cameraRig = useRef( new Index( camera, scene ) );
	future.rig.camera = camera;
	future.rig.scene = scene;
	future.gl = fbo.current;

	const focus = useRef( false );
	const tvMat2 = useSceneMaterial( {
		url: url,
		intensity: intensity,
		renderedScene: children ? fbo.current.texture : undefined
	} );

	useEffect( () => {

		camera.aspect = 0.5 / 0.42;
		camera.updateProjectionMatrix();
		// addContext( fbo, scene, camera );

	}, [] );

	// usePostProcess();

	useFrame( ( state ) => {

		// Copy the default cameras whereabouts
		if ( ! cameraInit.current ) {

			camera.position.copy( state.camera.position );
			camera.rotation.copy( state.camera.rotation );
			camera.scale.copy( state.camera.scale );
			cameraInit.current = true;

		}

		if ( hovered ) {

			tvMat2.uniforms.altScene.value = 1;

		} else {

			tvMat2.uniforms.altScene.value = 0;

		}


		state.gl.setRenderTarget( fbo.current );
		state.gl.render( scene, camera );
		state.gl.setRenderTarget( null );

		tvMat2.uniforms.time.value = state.clock.getElapsedTime() / 2;
		tvMat2.uniforms.intensity.value = intensity + ( intensity / 4 * Math.sin( state.clock.getElapsedTime() ) );

	} );

	// This is a custom raycast-compute function, it controls how the raycaster functions.
	const compute = useCallback( ( event: Event, state: any, previous: any ) => {

		// First we call the previous state-onion-layers compute, this is what makes it possible to nest portals
		if ( ! previous.raycaster.camera ) previous.events.compute( event, previous, previous.previousRoot?.getState() );
		// We run a quick check against the textured plane itself, if it isn't hit there's no need to raycast at all
		const [ intersection ] = previous.raycaster.intersectObject( ref.current ?? undefined );
		if ( ! intersection ) return false;
		// We take that hits uv coords, set up this layers raycaster, et voilÃ , we have raycasting with perspective shift
		const uv = intersection.uv;
		state.raycaster.setFromCamera( state.pointer.set( uv.x * 2 - 1, uv.y * 2 - 1 ), camera );

	}, [] );

	const handleClick = ( e: Event ) => {

		// e.preventDefault();
		// ( route != null ) && router.push( route );
		if ( activeScene === 2 ) return;
		// setFuture( fbo.current, scene, camera, cameraRig.current );
		const { position: p1, quaternion: q1 } = present.rig.getWorldCoordinates();
		present.rig.flyTo( new THREE.Vector3( p1.x, p1.y, p1.z - 5 ), q1, 2, "power3.inOut" );
		setTimeout( () => {

			setActiveScene( 2 );
			gsap.to( paneSettings, { scale: 3, distortion: 1, duration: 0.5, ease: "power3.inOut" } );

		}, 1000 );
		setTimeout( () => {

			// setActiveScene( 2 );
			gsap.to( paneSettings, { scale: 0, distortion: 0, duration: 0.25, ease: "power3.inOut" } );
			const { position: p2, quaternion: q2 } = present.rig.getWorldCoordinates();
			present.rig.flyTo( new THREE.Vector3( p2.x, p2.y, p2.z + 5 ), q2, 2, "power3.inOut" );
			setTimeout( () => setActiveScene( 1 ), 1000 );

		}, 3000 );
		// forward();

	};

	return (
		<group ref={group} {...restProps} dispose={null}>
			<group
				name="Scene"
				onClick={( e ) => handleClick( e as unknown as Event )}
				onPointerOver={() => hover( true )}
				onPointerOut={() => hover( false )}
			>
				<mesh
					name="TV"
					args={[ nodes.TV.geometry, nodes.TV.material ]}
					position={[ - 0.0011, 0.0054, - 0.0071 ]}
					scale={5.0041}
				/>
				<mesh
					name="TVSCREEN"
					args={[ nodes.TVSCREEN.geometry, glassMat ]}
					position={[ - 0.0011, 0.0054, - 0.0071 ]}
					scale={5.0809}
				>
					<mesh ref={ref} material={tvMat2} position={[ - 0.085, 0.2525, 0.15 ]}>
						<planeGeometry args={[ 0.5, 0.42 ]}/>
					</mesh>
					{children && createPortal( children, scene, {
						camera,
						scene,
						gl,
						events: { compute, priority: events.priority - 1 }
					} )}
				</mesh>
				<mesh
					name="TVSCREENBEZEL"
					geometry={nodes.TVSCREENBEZEL.geometry}
					material={nodes.TVSCREENBEZEL.material}
					position={[ - 0.4388, 1.2966, 0.8396 ]}
					scale={[ 5.1008, 5.1032, 4.9647 ]}
				/>
			</group>
		</group>
	);

}

useGLTF.preload( FILE_URL );
