/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { ReactElement, useCallback, useEffect, useRef, useState } from 'react';
import { useCursor, useFBO, useGLTF } from '@react-three/drei';
import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader';
import { useVintageScreenMaterial } from "../shaders/vintageScreen";
import { useSceneMaterial } from "../shaders/scene";
import { useRouter } from "next/router";
import { useFrame, useThree, createPortal } from "@react-three/fiber";
import usePostProcess from "@/templates/hooks/usePostprocess";
import { useSceneStore } from "@/hooks/useStore";

type GLTFResult = GLTF & {
  nodes: {
    TV: THREE.Mesh
    TVSCREEN: THREE.Mesh
    TVSCREENBEZEL: THREE.Mesh
  }
  materials: {
    ['TV_Chayka-206']: THREE.MeshStandardMaterial
  }
}

type VintageTelevisionProps = {
  intensity?: number,
  route?: string,
  url: string,
  index?: number,
  children?: ReactElement[]
} & JSX.IntrinsicElements['group']

const glassMat = new THREE.MeshPhysicalMaterial( { roughness: 0, transmission: 1, thickness: 0.1 } );
const FILE_URL = "https://dqeczc7c9n9n1.cloudfront.net/models/vintageTelevision-1668539957/vintageTelevision.glb.gz";

export default function Model( props: VintageTelevisionProps ) {

	const router = useRouter();
	const [ hovered, hover ] = useState( false );
	const { url, route, index = 0, intensity = 200, children, ...restProps } = props;
	const group = useRef<THREE.Group>();
	const { nodes, materials } = useGLTF( FILE_URL ) as GLTFResult;
	const tvMat = useVintageScreenMaterial( { url: url, intensity: intensity } );


	useCursor( hovered );

	const ref = useRef();
	const fbo = useRef( useFBO() );
	const dummyFBO = useFBO();
	const { events, gl, scene: originScene, camera: originCamera } = useThree();
	const addedScene = useRef( false );
	const [ addContext, forward ] = useSceneStore( state => [ state.addContext, state.forward ] );
	// The portal will render into this scene
	const [ scene ] = useState( () => new THREE.Scene() );
	// We have our own camera in here, separate from the default
	const [ camera ] = useState( () => new THREE.PerspectiveCamera( 50, 1, 0.1, 1000 ) );
	const focus = useRef( false );
	const tvMat2 = useSceneMaterial( {
		url: url,
		intensity: intensity,
		renderedScene: children ? fbo.current.texture : undefined
	} );

	useEffect( () => {

		camera.aspect = 0.5 / 0.42;
		camera.updateProjectionMatrix();
		// addContext( fbo, scene, camera );

	}, [] );

	// usePostProcess();

	useFrame( ( state ) => {

		// Copy the default cameras whereabouts
		// camera.position.copy( state.camera.position );
		// camera.rotation.copy( state.camera.rotation );
		// camera.scale.copy( state.camera.scale );
		// Render into a WebGLRenderTarget as a texture (the FBO above)
		// state.gl.clearColor();
		// state.gl.setRenderTarget( fbo );
		// console.log( state.previousRoot );
		if ( hovered ) {

			// const temp;
			// addContext();
			// forward();

			// state.gl.setRenderTarget( state?.previousRoot?.gl?.renderTarget );
			// gl.setRenderTarget( fbo.current );
			// gl.setRenderTarget( null );
			// gl.render( scene, camera );
			// gl.setRenderTarget( null );
			// gl.render( originScene, originCamera );
			// gl.setRenderTarget( null );
			tvMat2.uniforms.altScene.value = 1;

		} else {

			// state.gl.setRenderTarget( fbo.current );
			tvMat2.uniforms.altScene.value = 0;

		}


		state.gl.setRenderTarget( fbo.current );
		state.gl.render( scene, camera );
		state.gl.setRenderTarget( null );

		tvMat2.uniforms.time.value = state.clock.getElapsedTime() / 2;
		tvMat2.uniforms.intensity.value = intensity + ( intensity / 4 * Math.sin( state.clock.getElapsedTime() ) );

	} );

	// This is a custom raycast-compute function, it controls how the raycaster functions.
	const compute = useCallback( ( event, state, previous ) => {

		// First we call the previous state-onion-layers compute, this is what makes it possible to nest portals
		if ( ! previous.raycaster.camera ) previous.events.compute( event, previous, previous.previousRoot?.getState() );
		// We run a quick check against the textured plane itself, if it isn't hit there's no need to raycast at all
		const [ intersection ] = previous.raycaster.intersectObject( ref.current );
		if ( ! intersection ) return false;
		// We take that hits uv coords, set up this layers raycaster, et voilÃ , we have raycasting with perspective shift
		const uv = intersection.uv;
		state.raycaster.setFromCamera( state.pointer.set( uv.x * 2 - 1, uv.y * 2 - 1 ), camera );

	}, [] );

	const connect = useCallback( ( event, state, previous ) => {

	}, [] );

	const handleClick = ( err ) => {

		// ( route != null ) && router.push( route );
		focus.current = true;

	};

	return (
		<group ref={group} {...restProps} dispose={null}>
			<group
				name="Scene"
				onClick={( e ) => handleClick( e )}
				onPointerOver={() => hover( true )}
				onPointerOut={() => hover( false )}
			>
				<mesh
					name="TV"
					args={[ nodes.TV.geometry, nodes.TV.material ]}
					position={[ - 0.0011, 0.0054, - 0.0071 ]}
					scale={5.0041}
				/>
				<mesh
					name="TVSCREEN"
					args={[ nodes.TVSCREEN.geometry, glassMat ]}
					position={[ - 0.0011, 0.0054, - 0.0071 ]}
					scale={5.0809}
				>
					<mesh ref={ref} material={tvMat2} position={[ - 0.085, 0.2525, 0.15 ]}>
						<planeGeometry args={[ 0.5, 0.42 ]}/>
					</mesh>
					{children && createPortal( children, scene, {
						camera,
						scene,
						gl,
						events: { compute, priority: events.priority - 1 }
					} )}
				</mesh>
				<mesh
					name="TVSCREENBEZEL"
					geometry={nodes.TVSCREENBEZEL.geometry}
					material={nodes.TVSCREENBEZEL.material}
					position={[ - 0.4388, 1.2966, 0.8396 ]}
					scale={[ 5.1008, 5.1032, 4.9647 ]}
				/>
			</group>
		</group>
	);

}

useGLTF.preload( FILE_URL );
