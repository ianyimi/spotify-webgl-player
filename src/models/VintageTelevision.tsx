/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.2 public/staging/vintageTelevision/vintageTelevision.glb C:/Program Files/Git/src/models/vintageTelevision.tsx -d -t -v -p 4
*/

import { Group, Mesh, MeshStandardMaterial, MeshPhysicalMaterial, Scene, PerspectiveCamera, Vector3 } from 'three';
import { Dispatch, ReactElement, SetStateAction, useCallback, useEffect, useRef, useState } from 'react';
import { useCursor, useFBO, useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { Quaternion, Object3D } from "three";

import { gsap } from "gsap";
import { useSceneMaterial } from "../../public/shaders/scene/index";
import { useRouter } from "next/router";
import { useFrame, useThree, createPortal, ThreeEvent } from "@react-three/fiber";
import { useClientStore } from "@/hooks/useStore";
import { CameraAction, CameraRig } from "three-story-controls";
import { AnimationDuration, AnimationEase, CameraAnimationStatus } from 'types/common';

type GLTFResult = GLTF & {
  nodes: {
    TV: Mesh
    TVSCREEN: Mesh
    TVSCREENBEZEL: Mesh
  }
  materials: {
    ['TV_Chayka-206']: MeshStandardMaterial
  }
}

type VintageTelevisionProps = {
  intensity?: number,
	playlistID?: string,
	cameraAnimationStatus?: CameraAnimationStatus,
	setCameraAnimationStatus?: Dispatch<SetStateAction<CameraAnimationStatus>>,
  route?: string,
  url?: string,
  index?: number,
  children?: ReactElement[],
	focusedPlaylist?: string,
	setFocusPlaylistID?: Dispatch<SetStateAction<string>>
} & JSX.IntrinsicElements['group']

const glassMat = new MeshPhysicalMaterial( { roughness: 0, transmission: 1 } );
const FILE_URL = "https://dqeczc7c9n9n1.cloudfront.net/models/vintageTelevision-1672798597/vintageTelevision.glb.gz";
const URL_NOT_FOUND = "https://dqeczc7c9n9n1.cloudfront.net/images/404.png";

const UP_VECTOR = new Vector3( 0, 5, 7 );
const DOWN_VECTOR = new Vector3( 0, 1.5, 4 );
const DOWN_ANGLE = 0.35;

export default function Model( props: VintageTelevisionProps ) {

	const router = useRouter();
	const group = useRef<Group>( null );
	const [ hovered, hover ] = useState( false );
	const dummyCameraGroup = useRef( new Group() );
	const worldPosition = useRef( new Vector3() );
	const worldQuaternion = useRef( new Quaternion() );
	const { url = URL_NOT_FOUND, cameraAnimationStatus, setCameraAnimationStatus, playlistID, focusedPlaylist, setFocusPlaylistID, index = 0, intensity = 200, children, ...restProps } = props;
	const { nodes, materials } = useGLTF( FILE_URL ) as unknown as GLTFResult;

	useCursor( hovered );

	const screen = useRef( null );
	const fbo = useRef( useFBO() );
	const { events, gl, scene: originScene, camera: originCamera } = useThree();
	const cameraInit = useRef( false );
	const [ activeScene, present, setFuture, setActiveScene, paneSettings, sceneImmersion, sceneReversion ] = useClientStore( state => [ state.activeScene, state.present, state.setFuture, state.setActiveScene, state.paneSettings, state.sceneImmersion, state.sceneReversion ] );
	// The portal will render into this scene
	const [ futureScene ] = useState( () => new Scene() );
	// We have our own camera in here, separate from the default
	const [ futureCamera ] = useState( () => new PerspectiveCamera( 50, 1, 0.1, 1000 ) );
	const cameraRig = useRef( new CameraRig( futureCamera, futureScene ) );
	const tvMat = useSceneMaterial( {
		url: url,
		intensity: intensity,
		renderedScene: children ? fbo.current.texture : undefined
	} );

	if ( focusedPlaylist !== playlistID ) {

		tvMat.uniforms.altScene.value = 0;

	}

	useEffect( () => {

		futureCamera.aspect = 0.5 / 0.42;
		futureCamera.updateProjectionMatrix();

		if ( group.current ) {

			group.current.getWorldPosition( worldPosition.current );
			group.current.getWorldQuaternion( worldQuaternion.current );

			worldPosition.current.add( UP_VECTOR );
			worldQuaternion.current.x += DOWN_ANGLE;
			worldQuaternion.current.normalize().invert();

		}

	}, [] );

	useFrame( ( state ) => {

		if ( ! group.current ) return;
		// Copy the default cameras whereabouts
		if ( ! cameraInit.current ) {

			futureCamera.position.copy( state.camera.position );
			futureCamera.rotation.copy( state.camera.rotation );
			futureCamera.scale.copy( state.camera.scale );

			state.camera.getWorldPosition( dummyCameraGroup.current.position );
			state.camera.getWorldQuaternion( dummyCameraGroup.current.quaternion );
			state.camera.getWorldScale( dummyCameraGroup.current.scale );
			dummyCameraGroup.current.quaternion.normalize().invert();

			cameraInit.current = true;

		}

		state.gl.setRenderTarget( fbo.current );
		state.gl.render( futureScene, futureCamera );
		state.gl.setRenderTarget( null );

		tvMat.uniforms.time.value = state.clock.getElapsedTime() / 2;
		tvMat.uniforms.intensity.value = intensity + ( intensity / 4 * Math.sin( state.clock.getElapsedTime() ) );

	} );

	// This is a custom raycast-compute function, it controls how the raycaster functions.
	const compute = useCallback( ( event, state, previous ) => {

		// First we call the previous state-onion-layers compute, this is what makes it possible to nest portals
		if ( ! previous.raycaster.camera ) previous.events.compute( event, previous, previous.previousRoot?.getState() );
		// We run a quick check against the textured plane itself, if it isn't hit there's no need to raycast at all
		const [ intersection ] = previous.raycaster.intersectObject( screen.current );
		if ( ! intersection ) return false;
		// We take that hits uv coords, set up this layers raycaster, et voil√†, we have raycasting with perspective shift
		const uv = intersection.uv;
		state.raycaster.setFromCamera( state.pointer.set( uv.x * 2 - 1, uv.y * 2 - 1 ), futureCamera );

	}, [] );

	const handleClick = ( e: ThreeEvent<MouseEvent> ) => {

		e.intersections.length = 1;

		if ( cameraAnimationStatus !== CameraAnimationStatus.idle ) return;
		if ( ! present || ! group.current || activeScene === 2 ) return;
		if ( ! worldPosition.current || ! worldQuaternion.current ) return;
		if ( focusedPlaylist === playlistID ) {

			setCameraAnimationStatus && setCameraAnimationStatus( CameraAnimationStatus.animating );
			worldPosition.current.sub( UP_VECTOR ).add( DOWN_VECTOR );
			worldQuaternion.current.x += DOWN_ANGLE;
			present.rig.flyTo( worldPosition.current, worldQuaternion.current, AnimationDuration.CameraMotion, AnimationEase.CubicBezier );
			setTimeout( () => {

				present.rig.flyTo( worldPosition.current, worldQuaternion.current, AnimationDuration.CameraMotion, AnimationEase.CubicBezier );
				sceneImmersion();
				setTimeout( () => {

					sceneReversion();
					worldPosition.current.sub( DOWN_VECTOR ).add( UP_VECTOR );
					present.rig.flyTo( worldPosition.current, worldQuaternion.current, AnimationDuration.CameraMotion, AnimationEase.CubicBezier );
					worldQuaternion.current.x -= DOWN_ANGLE;
					setTimeout( () => setCameraAnimationStatus && setCameraAnimationStatus( CameraAnimationStatus.idle ), AnimationDuration.CameraMotion * 1000 + 500 );

				}, 3000 );

			}, AnimationDuration.CameraMotion * 1000 + 200 );

		}

		setCameraAnimationStatus && setCameraAnimationStatus( CameraAnimationStatus.animating );
		tvMat.uniforms.altScene.value = 1;
		setFocusPlaylistID && setFocusPlaylistID( playlistID ?? "" );
		setFuture( fbo.current, futureScene, futureCamera, cameraRig.current );
		present.rig.flyTo( worldPosition.current, worldQuaternion.current, AnimationDuration.CameraMotion, AnimationEase.CubicBezier );
		setTimeout( () => setCameraAnimationStatus && setCameraAnimationStatus( CameraAnimationStatus.idle ), AnimationDuration.CameraMotion * 1000 );

	};

	return (
		<group ref={group} {...restProps} dispose={null}>
			<group
				name="Scene"
				onClick={( e ) => handleClick( e )}
				onPointerOver={() => hover( true )}
				onPointerOut={() => hover( false )}
			>
				<mesh
					geometry={nodes.TV.geometry}
					material={materials[ 'TV_Chayka-206' ]}
					position={[ - 0.0011, 0.0054, - 0.0071 ]}
					scale={5.0041}
				/>
				<mesh
					geometry={nodes.TVSCREEN.geometry}
					args={[ nodes.TVSCREEN.geometry, glassMat ]}
					position={[ - 0.0011, 0.0054, - 0.0071 ]}
					scale={5.0809}
				>
					<mesh ref={screen} material={tvMat} position={[ - 0.085, 0.2525, 0.15 ]}>
						<planeGeometry args={[ 0.5, 0.42 ]}/>
					</mesh>
					{children && createPortal( children, futureScene, {
						gl,
						camera: futureCamera,
						scene: futureScene,
						events: { compute, priority: events.priority - 1 }
					} )}
				</mesh>
				<mesh
					geometry={nodes.TVSCREENBEZEL.geometry}
					material={materials[ 'TV_Chayka-206' ]}
					position={[ - 0.4388, 1.2966, 0.8396 ]}
					scale={[ 5.1008, 5.1032, 4.9647 ]}
				/>
			</group>
		</group>
	);

}

useGLTF.preload( FILE_URL );
